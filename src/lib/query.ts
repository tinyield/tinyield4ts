import {bye, Yield} from './yield';
import {AbstractAdvancer, Advanceable, Advancer, UNDEFINED_ADVANCER, UNDEFINED_ADVANCER_ERROR} from './advancer';
import {FromArray} from './ops/from-array';
import {Filter} from './ops/filter';
import {Mapping} from './ops/mapping';
import {Skip} from './ops/skip';
import {SHORT_CIRCUITING_ERROR, Traverser} from '../public-api';
import {Take} from './ops/take';
import {Distinct} from './ops/distinct';
import {FromIterator} from './ops/from-iterator';
import {Zip} from './ops/zip';
import {Flatmap} from './ops/flatmap';
import {Peek} from './ops/peek';
import {TakeWhile} from './ops/take-while';
import {Generate} from './ops/generate';
import {Concat} from './ops/concat';
import {DropWhile} from './ops/drop-while';
import {AbstractTraverser, Traversable} from './traverser';
import {Operation} from './operation';
import {Sequence} from './sequence';

export class Query<T> implements Advanceable<T>, Traversable<T>, Sequence<T> {
    public readonly adv: Advanceable<T>;
    public readonly trv: Traversable<T>;

    public constructor(adv: Advanceable<T>, trv: Traversable<T>) {
        this.adv = adv;
        this.trv = trv;
    }

    /**
     * Returns a sequential ordered Query whose elements
     * are the specified values in source parameter.
     */
    public static of<T>(source: T[]): Query<T> {
        return Query.fromOp(new FromArray(source));
    }

    /**
     * Returns an empty Query.
     */
    public static empty<T>(): Query<T> {
        return new Query(AbstractAdvancer.empty(), AbstractTraverser.empty());
    }

    /**
     * Returns an infinite sequential ordered {@code Query} produced by iterative
     * application of a function {@code operation} to an initial element {@code seed},
     * producing a {@code Query} consisting of {@code seed}, {@code operation(seed)},
     * {@code operation(operation(seed))}, etc.
     *
     */
    public static iterate<T>(seed: T, operation: (elem: T) => T): Query<T> {
        return Query.fromOp(new FromIterator(seed, operation));
    }

    /**
     * Returns an infinite sequential unordered {@code Query}
     * where each element is generated by the provided Supplier.
     */
    static generate<T>(supplier: () => T): Query<T> {
        return Query.fromOp(new Generate(supplier));
    }

    private static fromOp<R>(op: Operation<R>): Query<R> {
        return new Query<R>(op, op);
    }

    /**
     * If a remaining element exists, yields that element through
     * the given action.
     */
    tryAdvance(yld: Yield<T>): boolean {
        return this.adv.tryAdvance(yld);
    }

    /**
     * Yields elements sequentially in the current thread,
     * until all elements have been processed or an
     * exception is thrown.
     */
    forEach(yld: Yield<T>): void {
        this.trv.traverse(yld);
    }

    /**
     * Yields elements sequentially in the current thread,
     * until all elements have been processed or an
     * exception is thrown.
     */
    traverse(yld: Yield<T>): void {
        this.trv.traverse(yld);
    }

    /**
     * Returns an array containing the elements of this Query.
     */
    toArray(): T[] {
        const result: T[] = [];
        this.trv.traverse(element => result.push(element));
        return result;
    }

    /**
     * Returns a {@code Query} consisting of the elements of this {@code Query},
     * sorted according to the provided Comparator.
     *
     * This is a stateful intermediate operation.
     */
    sorted(comparator: (a: T, b: T) => number): Query<T> {
        return Query.fromOp(new FromArray(this.toArray().sort(comparator)));
    }

    /**
     * Returns a query consisting of the elements of this Query that match
     * the given predicate.
     */
    filter(predicate: (elem: T) => boolean): Query<T> {
        return Query.fromOp(new Filter(this, predicate));
    }

    /**
     * Returns a Query consisting of the results of applying the given
     * function to the elements of this Query.
     */
    map<R>(mapper: (elem: T) => R): Query<R> {
        return Query.fromOp(new Mapping(this, mapper));
    }

    /**
     * Returns a Query consisting of the remaining elements of this Query
     * after discarding the first {@code n} elements of the Query.
     */
    skip(n: number): Query<T> {
        return Query.fromOp(new Skip(this, n));
    }

    /**
     * Returns a Query consisting of the elements ortf this Query, truncated
     * to be no longer than {@code n} in length.
     */
    take(n: number): Query<T> {
        return Query.fromOp(new Take(this, n));
    }

    /**
     * Returns a Query consisting of the elements of this Query, truncated
     * to be no longer than {@code n} in length.
     */
    takeWhile(predicate: (elem: T) => boolean): Query<T> {
        return Query.fromOp(new TakeWhile(this, predicate));
    }

    /**
     * Returns the first element of this Query or undefined if the
     * Query is empty.
     */
    first(): T {
        let first: T;
        this.tryAdvance(elem => (first = elem));
        return first;
    }

    /**
     * Yields elements sequentially in the current thread,
     * until all elements have been processed or the traversal
     * exited normally through the invocation of bye().
     */
    shortCircuit(yld: Yield<T>): void {
        try {
            this.trv.traverse(yld);
        } catch (error) {
            if (SHORT_CIRCUITING_ERROR !== error) {
                throw error;
            }
        }
    }

    /**
     * Returns a query consisting of the distinct elements of this Query.
     */
    distinct(): Query<T> {
        return this.distinctBy(elem => elem);
    }

    /**
     * Returns a query consisting of the distinct elements of this Query
     * by the specified key.
     */
    distinctByKey(key: keyof T): Query<T> {
        return this.distinctBy(elem => elem[key]);
    }

    /**
     * Returns a query consisting of the distinct elements of this Query
     * by the specified selector.
     */
    distinctBy<U>(selector: (elem: T) => U): Query<T> {
        return Query.fromOp(new Distinct(this, selector));
    }

    /**
     * The {@code then} operator lets you encapsulate a piece of an operator
     * chain into a function.
     * That function {@code next} is applied to this query to produce a new
     * {@code Traverser} object that is encapsulated in the resulting query.
     * On the other hand, the {@code nextAdv} is applied to this query to produce a new
     * {@code Advancer} object that is encapsulated in the resulting query.
     *
     * @throws Error if {@code nextAdv} is undefined and a shortCircuiting operation is called
     */
    then<U>(nextTrv: (source: Query<T>) => Traverser<U>, nextAdv?: (source: Query<T>) => Advancer<U>): Query<U> {
        if (nextAdv !== undefined) {
            return new Query<U>(AbstractAdvancer.of(nextAdv(this)), AbstractTraverser.of(nextTrv(this)));
        }
        return new Query<U>(UNDEFINED_ADVANCER, AbstractTraverser.of(nextTrv(this)));
    }

    /**
     * Applies a specified function to the corresponding elements of two
     * sequences, producing a sequence of the results.
     */
    zip<U, R>(other: Query<U>, zipper: (elem1: T, elem2: U) => R): Query<R> {
        return Query.fromOp(new Zip(this, other, zipper));
    }

    /**
     * Returns a Query consisting of the results of replacing each element of
     * this Query with the contents of a mapped query produced by applying
     * the provided mapping function to each element.
     */
    flatMap<R>(mapper: (elem: T) => Query<R>): Query<R> {
        return Query.fromOp(new Flatmap(this, mapper));
    }

    /**
     * Returns a Query consisting of the elements of this Query, additionally
     * performing the provided action on each element as elements are consumed
     * from the resulting Query.
     */
    peek(action: (elem: T) => void): Query<T> {
        return Query.fromOp(new Peek(this, action));
    }

    /**
     * Returns the maximum element of this query according to the provided
     * comparator.  This is a special case of a reduction.
     */
    max(comparator: (a: T, b: T) => number): T {
        let maxValue: T;
        this.traverse(element => {
            if (maxValue === undefined || comparator(element, maxValue) > 0) {
                maxValue = element;
            }
        });
        return maxValue;
    }

    /**
     * Returns the minimum element of this query according to the provided
     * comparator.  This is a special case of a reduction.
     */
    min(comparator: (a: T, b: T) => number): T {
        return this.max((a, b) => comparator(a, b) * -1);
    }

    /**
     * Returns whether any elements of this query match the provided
     * predicate.  May not evaluate the predicate on all elements if not
     * necessary for determining the result.  If the query is empty then
     * {@code false} is returned and the predicate is not evaluated.
     */
    anyMatch(predicate: (elem: T) => boolean): boolean {
        let found = false;
        try {
            const yld = (elem: T) => {
                if (predicate(elem)) {
                    found = true;
                }
            };
            while (!found && this.adv.tryAdvance(yld)) {
                // Doing work on try advance
            }
        } catch (e) {
            if (e !== UNDEFINED_ADVANCER_ERROR) {
                throw e;
            }
            this.shortCircuit((elem: T) => {
                if (predicate(elem)) {
                    found = true;
                    bye();
                }
            });
        }
        return found;
    }

    /**
     * Returns whether all elements of this query match the provided
     * predicate. May not evaluate the predicate on all elements if not
     * necessary for determining the result. If the query is empty then
     * {@code true} is returned and the predicate is not evaluated.
     */
    allMatch(predicate: (elem: T) => boolean): boolean {
        let succeed = true;
        try {
            const yld = (elem: T) => {
                if (!predicate(elem)) {
                    succeed = false;
                }
            };
            while (succeed && this.adv.tryAdvance(yld)) {
                // Doing work on try advance
            }
        } catch (e) {
            if (e !== UNDEFINED_ADVANCER_ERROR) {
                throw e;
            }
            this.shortCircuit((elem: T) => {
                if (!predicate(elem)) {
                    succeed = false;
                    bye();
                }
            });
        }
        return succeed;
    }

    /**
     * Returns the count of elements in this query.
     */
    count(): number {
        let counter = 0;
        this.traverse(() => {
            counter++;
        });
        return counter;
    }

    /**
     * Returns the result of the reduction of the elements of this query,
     * using the provided identity value and accumulator.
     */
    reduce(accumulator: (acc: T, curr: T) => T, identity?: T): T {
        let result = identity;
        if (identity === undefined) {
            this.tryAdvance(item => (result = item));
        }
        this.traverse(elem => (result = accumulator(result, elem)));
        return result;
    }

    /**
     * Returns the sum of elements in this {@code Query} .
     * <p>
     * This is a special case of a reduction.
     */
    sum(by: (elem: T) => number): number {
        return this.map(by).reduce((acc, curr) => acc + curr, 0);
    }

    /**
     * Returns an number describing the arithmetic mean of elements of this {@code Query},
     * or undefined if this {@code Query} is empty. This is a special case of a reduction.
     * <p>
     * This is a terminal operation.
     */
    average(by: (elem: T) => number): number {
        const data = this.toArray();
        const count = data.length;
        if (count === 0) {
            return undefined;
        }

        return Query.of(data).sum(by) / count;
    }

    /**
     * Returns a {@link Set} containing the elements of this query.
     */
    toSet(): Set<T> {
        const data = new Set<T>();
        this.traverse(elem => data.add(elem));
        return data;
    }

    /**
     * Returns the concatenation of the input elements into a String, in encounter order.
     */
    join(): string {
        return this.map(elem => JSON.stringify(elem)).reduce((acc, curr) => acc + curr);
    }

    /**
     * Returns whether no elements of this query match the provided
     * predicate. May not evaluate the predicate on all elements if not
     * necessary for determining the result. If the query is empty then
     * {@code true} is returned and the predicate is not evaluated.
     */
    noneMatch(predicate: (elem: T) => boolean): boolean {
        return !this.anyMatch(predicate);
    }

    /**
     * Performs a mutable reduction operation on the elements of this {@code Query}.
     * A mutable reduction is one in which the reduced value is a mutable result container, such as an Array,
     * and elements are incorporated by updating the state of the result rather than by replacing the result.
     */
    collect<R>(supplier: () => R, accumulator: (container: R, element: T) => void): R {
        const result = supplier();
        this.traverse(elem => accumulator(result, elem));
        return result;
    }

    /**
     * Creates a concatenated {@code Query} in which the elements are
     * all the elements of this {@code Query} followed by all the
     * elements of the other {@code Query}.
     */
    concat(other: Query<T>): Query<T> {
        return Query.fromOp(new Concat(this, other));
    }

    /**
     * Returns a {@code Query} consisting of the remaining elements of this query
     * after discarding the first sequence of elements that match the given Predicate.
     */
    dropWhile(predicate: (elem: T) => boolean): Query<T> {
        return Query.fromOp(new DropWhile(this, predicate));
    }
}

/**
 * Returns a sequential ordered Query whose elements
 * are the specified values in source parameter.
 */
export function of<T>(source: T[]): Query<T> {
    return Query.of(source);
}

/**
 * Returns an infinite sequential ordered {@code Query} produced by iterative
 * application of a function {@code operation} to an initial element {@code seed},
 * producing a {@code Query} consisting of {@code seed}, {@code operation(seed)},
 * {@code operation(operation(seed))}, etc.
 *
 */
export function iterate<T>(seed: T, operation: (elem: T) => T): Query<T> {
    return Query.iterate(seed, operation);
}

/**
 * Returns an infinite sequential unordered {@code Query}
 * where each element is generated by the provided Supplier.
 */
export function generate<T>(supplier: () => T): Query<T> {
    return Query.generate(supplier);
}

/**
 * Returns an empty Query.
 */
export function empty<T>(): Query<T> {
    return Query.empty();
}
